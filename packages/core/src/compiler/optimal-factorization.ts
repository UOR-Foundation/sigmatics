/**
 * Optimal Factorization via E₇ Eigenspace Metric
 *
 * Implements the algorithm described in FACTORIZATION-CLOSURE-THEOREM.md
 * for finding minimal-complexity factorization paths in ℤ₉₆.
 *
 * Key insight: While factorization doesn't compose with orbit transforms,
 * it DOES exhibit closure under the eigenspace metric:
 *
 *   d_E(F(n), F(m)) ≤ d_orbit(n, m) + ε
 *
 * This enables optimal path finding using matrix powers.
 */

import { buildE7Matrix, matrixPower } from './e7-matrix';
import { computeFactor96 } from './lowering/class-backend';

/**
 * Factorization with complexity metrics
 */
export interface OptimalFactorization {
  /** Input value in ℤ₉₆ */
  input: number;
  /** Prime factorization */
  factors: readonly number[];
  /** Orbit distance from prime generator 37 */
  orbitDistance: number;
  /** Complexity score: α·|factors| + β·Σd(fᵢ) + γ·max d(fᵢ) */
  complexity: number;
  /** Optimal path from 37 to input */
  path: readonly {
    from: number;
    to: number;
    transform: 'R' | 'D' | 'T' | 'M' | 'I';
  }[];
  /** Eigenspace distance from 37 */
  eigenspaceDistance: number;
}

/**
 * Weight parameters for complexity functional
 */
export interface ComplexityWeights {
  /** Factor count weight (default: 10) */
  alpha: number;
  /** Orbit distance sum weight (default: 1) */
  beta: number;
  /** Maximum factor distance weight (default: 0.5) */
  gamma: number;
}

/**
 * Default complexity weights
 */
export const DEFAULT_WEIGHTS: ComplexityWeights = {
  alpha: 10,
  beta: 1,
  gamma: 0.5,
};

/**
 * Precomputed orbit distance table from prime generator 37
 * Generated by BFS traversal of E₇ orbit graph
 */
export const ORBIT_DISTANCE_TABLE: readonly number[] = [
  9, 8, 9, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 3, 10, 10, 10, 10, 10, 3, 10, 10,
  10, 10, 10, 7, 7, 10, 10, 2, 7, 7, 3, 7, 10, 10, 6, 0, 1, 3, 10, 10, 10, 7,
  7, 1, 6, 7, 7, 7, 7, 7, 3, 10, 7, 7, 10, 7, 2, 7, 7, 1, 7, 10, 10, 7, 7, 7,
  10, 10, 7, 7, 10, 7, 1, 10, 10, 10, 7, 10, 10, 10, 10, 10, 10, 7, 10, 2, 10,
  10, 10, 10, 10, 7, 7, 7,
];

/**
 * Compute complexity score for a factorization
 */
export function computeComplexity(
  factors: readonly number[],
  weights: ComplexityWeights = DEFAULT_WEIGHTS,
): number {
  const factorCount = factors.length;
  const orbitDistances = factors.map((f) => ORBIT_DISTANCE_TABLE[f]);
  const sumDistance = orbitDistances.reduce((sum, d) => sum + d, 0);
  const maxDistance = Math.max(...orbitDistances);

  return weights.alpha * factorCount + weights.beta * sumDistance + weights.gamma * maxDistance;
}

/**
 * Build BFS tree to find shortest paths from source
 */
function buildBFSTree(
  matrix: readonly (readonly number[])[],
  source: number,
): Map<number, { parent: number; distance: number; transform: 'R' | 'D' | 'T' | 'M' | 'I' }> {
  const n = matrix.length;
  const visited = new Set<number>();
  const tree = new Map<
    number,
    { parent: number; distance: number; transform: 'R' | 'D' | 'T' | 'M' | 'I' }
  >();

  // Import models for transform detection
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  const { Atlas } = require('../index');

  const RModel = Atlas.Model.R(1);
  const DModel = Atlas.Model.D(1);
  const TModel = Atlas.Model.T(1);
  const MModel = Atlas.Model.M();

  const queue: { node: number; parent: number; distance: number }[] = [
    { node: source, parent: source, distance: 0 },
  ];
  visited.add(source);
  tree.set(source, { parent: source, distance: 0, transform: 'I' });

  while (queue.length > 0) {
    const { node, parent, distance } = queue.shift()!;

    // Find neighbors and detect which transform was used
    for (let neighbor = 0; neighbor < n; neighbor++) {
      if (matrix[node][neighbor] === 1 && !visited.has(neighbor)) {
        visited.add(neighbor);

        // Detect transform type
        let transform: 'R' | 'D' | 'T' | 'M' | 'I' = 'I';
        if (neighbor !== node) {
          const R_result = RModel.run({ x: node }) as number;
          const D_result = DModel.run({ x: node }) as number;
          const T_result = TModel.run({ x: node }) as number;
          const M_result = MModel.run({ x: node }) as number;

          if (R_result === neighbor) transform = 'R';
          else if (D_result === neighbor) transform = 'D';
          else if (T_result === neighbor) transform = 'T';
          else if (M_result === neighbor) transform = 'M';
        }

        tree.set(neighbor, { parent: node, distance: distance + 1, transform });
        queue.push({ node: neighbor, parent: node, distance: distance + 1 });
      }
    }
  }

  return tree;
}

/**
 * Extract path from source to target using BFS tree
 */
function extractPath(
  tree: Map<number, { parent: number; distance: number; transform: 'R' | 'D' | 'T' | 'M' | 'I' }>,
  target: number,
): readonly { from: number; to: number; transform: 'R' | 'D' | 'T' | 'M' | 'I' }[] {
  const path: { from: number; to: number; transform: 'R' | 'D' | 'T' | 'M' | 'I' }[] = [];
  let current = target;

  while (true) {
    const node = tree.get(current);
    if (!node) break;
    if (node.parent === current) break; // Reached source

    path.unshift({ from: node.parent, to: current, transform: node.transform });
    current = node.parent;
  }

  return path;
}

/**
 * Compute eigenspace distance using dominant eigenvector
 */
function computeEigenspaceDistance(
  matrix: readonly (readonly number[])[],
  from: number,
  to: number,
): number {
  // For now, use BFS distance as proxy
  // Full eigenspace implementation would require eigenvector decomposition
  const tree = buildBFSTree(matrix, from);
  const node = tree.get(to);
  return node ? node.distance : Infinity;
}

/**
 * Find optimal factorization for n ∈ ℤ₉₆
 *
 * Algorithm:
 * 1. Compute orbit path from 37 → n
 * 2. Factor n using standard factorization
 * 3. Compute complexity score
 * 4. Return factorization with metrics
 */
export function findOptimalFactorization(
  n: number,
  weights: ComplexityWeights = DEFAULT_WEIGHTS,
): OptimalFactorization {
  if (n < 0 || n >= 96) {
    throw new Error(`findOptimalFactorization: n must be in [0, 95], got ${n}`);
  }

  // Build E₇ matrix and BFS tree from prime generator 37
  const E7 = buildE7Matrix();
  const tree = buildBFSTree(E7, 37);

  // Extract path from 37 to n
  const path = extractPath(tree, n);

  // Get orbit distance
  const orbitDistance = ORBIT_DISTANCE_TABLE[n];

  // Factor n
  const factors = computeFactor96(n);

  // Compute complexity
  const complexity = computeComplexity(factors, weights);

  // Compute eigenspace distance
  const eigenspaceDistance = computeEigenspaceDistance(E7, 37, n);

  return {
    input: n,
    factors,
    orbitDistance,
    complexity,
    path,
    eigenspaceDistance,
  };
}

/**
 * Find all optimal factorizations for ℤ₉₆
 * Returns array sorted by complexity (best first)
 */
export function findAllOptimalFactorizations(
  weights: ComplexityWeights = DEFAULT_WEIGHTS,
): readonly OptimalFactorization[] {
  const results: OptimalFactorization[] = [];

  for (let n = 0; n < 96; n++) {
    results.push(findOptimalFactorization(n, weights));
  }

  // Sort by complexity (ascending)
  return results.sort((a, b) => a.complexity - b.complexity);
}

/**
 * Validate eigenspace closure property:
 * d_E(F(n), F(m)) ≤ d_orbit(n, m) + ε
 */
export function validateEigenspaceClosure(
  n: number,
  m: number,
  epsilon = 0.1,
): {
  valid: boolean;
  eigenspaceDistance: number;
  orbitDistance: number;
  factorizations: {
    n: readonly number[];
    m: readonly number[];
  };
} {
  const E7 = buildE7Matrix();

  // Get factorizations
  const f_n = computeFactor96(n);
  const f_m = computeFactor96(m);

  // Compute orbit distance
  const tree = buildBFSTree(E7, n);
  const node = tree.get(m);
  const orbitDistance = node ? node.distance : Infinity;

  // Compute eigenspace distance between factorizations
  // For now, use simple proxy: difference in complexity
  const complexity_n = computeComplexity(f_n);
  const complexity_m = computeComplexity(f_m);
  const eigenspaceDistance = Math.abs(complexity_n - complexity_m);

  // Validate closure: d_E ≤ d_orbit + ε
  const valid = eigenspaceDistance <= orbitDistance + epsilon;

  return {
    valid,
    eigenspaceDistance,
    orbitDistance,
    factorizations: { n: f_n, m: f_m },
  };
}

/**
 * Find minimal-complexity path from 37 to target using matrix powers
 *
 * Uses the key property that E₇^k[i][j] counts k-step paths from i to j.
 * Optimal paths minimize weighted sum over eigenvalues.
 */
export function findMinimalComplexityPath(
  target: number,
  maxSteps = 12,
): {
  steps: number;
  pathCount: number;
  complexity: number;
} {
  const E7 = buildE7Matrix();

  // Find minimum k such that E₇^k[37][target] > 0
  let minSteps = 0;
  for (let k = 0; k <= maxSteps; k++) {
    const Ek = matrixPower(E7, k);
    const pathCount = Ek[37][target];

    if (pathCount > 0) {
      minSteps = k;
      const factors = computeFactor96(target);
      const complexity = computeComplexity(factors);

      return { steps: minSteps, pathCount, complexity };
    }
  }

  // Not reachable within maxSteps
  return { steps: Infinity, pathCount: 0, complexity: Infinity };
}

/**
 * Compare factorization complexity across all classes
 * Returns statistics about the distribution
 */
export function analyzeComplexityDistribution(
  weights: ComplexityWeights = DEFAULT_WEIGHTS,
): {
  mean: number;
  median: number;
  min: number;
  max: number;
  stdDev: number;
  histogram: Map<number, number>;
} {
  const factorizations = findAllOptimalFactorizations(weights);
  const complexities = factorizations.map((f) => f.complexity);

  const sorted = [...complexities].sort((a, b) => a - b);
  const mean = complexities.reduce((sum, c) => sum + c, 0) / complexities.length;
  const median = sorted[Math.floor(sorted.length / 2)];
  const min = sorted[0];
  const max = sorted[sorted.length - 1];

  const variance =
    complexities.reduce((sum, c) => sum + (c - mean) ** 2, 0) / complexities.length;
  const stdDev = Math.sqrt(variance);

  // Build histogram (group by complexity value)
  const histogram = new Map<number, number>();
  for (const c of complexities) {
    histogram.set(c, (histogram.get(c) ?? 0) + 1);
  }

  return { mean, median, min, max, stdDev, histogram };
}
